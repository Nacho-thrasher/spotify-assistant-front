import React, { useState, useEffect, useCallback, useRef } from 'react';
import styled from 'styled-components';
import { NavLink, useLocation } from 'react-router-dom';
import { FiLogOut, FiMusic, FiRefreshCw, FiMessageSquare, FiBarChart2 } from 'react-icons/fi';
import MusicPlayer from '../ui/MusicPlayer';
import Button from '../ui/Button';
import QueueDisplay from '../ui/QueueDisplay';
import { useAuth } from '../../contexts/AuthContext';
import { useAssistant } from '../../contexts/AssistantContext';
import { spotifyService } from '../../services/api';
import { toast } from 'react-toastify';
import AppRouter from '../../routes';
import trackingService from '../../services/trackingService';

const AppContainer = styled.div`
  display: flex;
  flex-direction: column;
  height: 100vh;
  background-color: #121212;
  color: white;
`;

const Header = styled.header`
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px 24px;
  background-color: #070707;
  border-bottom: 1px solid #333;
`;

const Logo = styled.div`
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 20px;
  font-weight: bold;
  color: #1DB954;
`;

const Main = styled.main`
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
`;

const PlayerSection = styled.div`
  padding: 16px;
  background-color: #181818;
  position: relative;
`;

const RefreshButton = styled.button`
  position: absolute;
  top: 12px;
  right: 12px;
  background: rgba(255, 255, 255, 0.1);
  border: none;
  color: #b3b3b3;
  width: 28px;
  height: 28px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.2s ease;
  z-index: 5;
  
  &:hover {
    background: rgba(255, 255, 255, 0.2);
    color: white;
    transform: scale(1.05);
  }
  
  &:active {
    transform: scale(0.95);
  }
  
  svg {
    transition: transform 0.5s ease;
  }
  
  &.loading svg {
    animation: spin 1s linear infinite;
  }
  
  @keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
  }
`;

const Navigation = styled.nav`
  background-color: #121212;
  border-bottom: 1px solid #333;
  padding: 0 24px;
`;

const NavList = styled.ul`
  display: flex;
  list-style: none;
  margin: 0;
  padding: 0;
`;

const NavItem = styled.li`
  margin-right: 20px;
`;

const StyledNavLink = styled(NavLink)`
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 12px 0;
  color: #b3b3b3;
  text-decoration: none;
  border-bottom: 2px solid transparent;
  transition: all 0.2s ease;
  
  &:hover {
    color: white;
  }
  
  &.active {
    color: #1DB954;
    border-bottom-color: #1DB954;
  }
`;

const ContentSection = styled.div`
  flex: 1;
  overflow: hidden;
`;

const AppLayout = () => {
  const { logout } = useAuth();
  const { currentTrack, isPlaying, setIsPlaying, queueItems, refreshQueue } = useAssistant();

  // Estado local para feedback visual y tracking
  const [isLoading, setIsLoading] = useState(false);
  const [isLoadingNext, setIsLoadingNext] = useState(false);
  const [isLoadingPrevious, setIsLoadingPrevious] = useState(false);
  const [isRefreshing, setIsRefreshing] = useState(false);
  
  // Sistema de cach√© para reducir peticiones innecesarias
  const [lastRequestTime, setLastRequestTime] = useState(0);
  const [lastTrackData, setLastTrackData] = useState(null);
  const MIN_REQUEST_INTERVAL = 15000; // 15 segundos m√≠nimo entre peticiones completas
  
  // Estado para la informaci√≥n de la pista actual (usado para sincronizar con Spotify)
  const [currentTrackInfo, setCurrentTrackInfo] = useState(null);
  
  // Estado para almacenar el ID de la √∫ltima canci√≥n (para detectar cambios)
  const [lastTrackId, setLastTrackId] = useState(null);
  
  // Referencia al intervalo de seguimiento autom√°tico
  const trackingIntervalRef = useRef(null);
  
  // Funci√≥n mejorada para actualizar la informaci√≥n del track actual y cola con control de cache
  const updateCurrentTrack = useCallback(async () => {
    try {
      // Evitar que se quede bloqueado el estado de carga si hay errores
      const refreshTimeout = setTimeout(() => {
        setIsRefreshing(false);
      }, 10000); // Tiempo m√°ximo de 10 segundos para evitar que se quede cargando indefinidamente
      
      setIsRefreshing(true);
      console.log('üîÑ AppLayout: Iniciando actualizaci√≥n completa de estado');
      
      // Obtener la informaci√≥n de reproducci√≥n actual
      const response = await spotifyService.getCurrentTrack();
      
      // Limpiar timeout ya que la petici√≥n ha sido exitosa
      clearTimeout(refreshTimeout);
      
      // Procesar los datos recibidos
      if (response && response.body) {
        const playbackData = response.body;
        
        if (playbackData.item) {
          // Si hay una canci√≥n reproduci√©ndose
          const track = playbackData.item;
          
          // Actualizar la informaci√≥n de la pista actual
          setCurrentTrackInfo({
            name: track.name,
            artist: track.artists[0].name,
            album: track.album.name,
            image: track.album.images[0]?.url,
            uri: track.uri,
            isPlaying: playbackData.is_playing
          });
          
          // Actualizar estado de reproducci√≥n
          setIsPlaying(playbackData.is_playing);
          
          // Actualizar ID de la √∫ltima pista
          setLastTrackId(track.id);
          
          console.log(`‚úÖ Estado actualizado: ${track.name} - ${track.artists[0].name} (${playbackData.is_playing ? 'reproduciendo' : 'pausado'})`);
        } else {
          // Si no hay canci√≥n reproduci√©ndose
          setCurrentTrackInfo(null);
          setIsPlaying(false);
          console.log('‚èπÔ∏è No hay pista reproduci√©ndose actualmente');
        }
        
        // Actualizar la cola de reproducci√≥n
        await refreshQueue();
      } else {
        console.log('‚ö†Ô∏è No se pudo obtener informaci√≥n de reproducci√≥n');
        setCurrentTrackInfo(null);
        setIsPlaying(false);
      }
    } catch (error) {
      console.error('‚ùå Error al actualizar estado:', error);
      // No modificar estado en caso de error para evitar falsos negativos
    } finally {
      setIsRefreshing(false);
    }
  }, [refreshQueue]);
  
  // Verificar cambios en pistas cada pocos segundos
  const checkForChanges = useCallback(() => {
    // Implementaci√≥n espec√≠fica del polling para necesidades de UI
    console.log('üïë Verificando cambios en pista...');
    spotifyService.getCurrentTrack()
      .then(data => {
        if (data) {
          if (data.item) {
            // Solo actualizar UI si cambi√≥ la pista o su estado
            if (!lastTrackId || lastTrackId !== data.item.id || isPlaying !== data.is_playing) {
              setLastTrackId(data.item.id);
              setCurrentTrackInfo({
                name: data.item.name,
                artist: data.item.artists[0].name,
                album: data.item.album.name,
                image: data.item.album.images[0]?.url,
                uri: data.item.uri,
                isPlaying: data.is_playing
              });
              setIsPlaying(data.is_playing);
            }
          } else {
            // Nada reproduciendo
            setCurrentTrackInfo(null);
            setIsPlaying(false);
          }
        }
      })
      .catch(err => console.error('Error en checkForChanges:', err));
  }, [lastTrackId, isPlaying]);

  // Funci√≥n para configurar polling
  const setupPolling = useCallback(() => {
    if (Date.now() - lastRequestTime > MIN_REQUEST_INTERVAL) {
      checkForChanges();
      setLastRequestTime(Date.now());
    }
  }, [checkForChanges, lastRequestTime]);
  
  // Iniciar el seguimiento autom√°tico de reproducci√≥n
  useEffect(() => {
    console.log('üîÑ Iniciando seguimiento autom√°tico de reproducci√≥n...');
    trackingIntervalRef.current = trackingService.startAutoTracking(15000); // Cada 15 segundos
    
    return () => {
      console.log('‚èπÔ∏è Deteniendo seguimiento autom√°tico de reproducci√≥n');
      if (trackingIntervalRef.current) {
        trackingService.stopAutoTracking(trackingIntervalRef.current);
        trackingIntervalRef.current = null;
      }
    };
  }, []); // Solo se ejecuta una vez al montar el componente
  
  // Polling peri√≥dico para sincronizar cuando hay track actual
  useEffect(() => {
    if (currentTrack) {
      console.log('üïí Configurando polling peri√≥dico para sincronizaci√≥n');
      const checkInterval = setInterval(setupPolling, 30000); // 30 segundos
      return () => clearInterval(checkInterval);
    }
  }, [currentTrack, setupPolling]);
  
  // Iniciar actualizaci√≥n inicial
  useEffect(() => {
    // Realizar una verificaci√≥n inmediata al iniciar
    console.log('üîÑ Realizando verificaci√≥n inicial de Spotify...');
    updateCurrentTrack();  
    
    // Al montar, actualizar cada 5 segundos
    const initialInterval = setInterval(() => {
      console.log('üïí Actualizaci√≥n programada inicial...');
      checkForChanges();
    }, 5000);

    // Limpiar al desmontar
    return () => clearInterval(initialInterval);
  }, [updateCurrentTrack, checkForChanges]);
  
  // Sincronizaci√≥n despu√©s de montar
  useEffect(() => {
    // Retraso de 3 segundos para permitir que otras cosas se inicialicen
    console.log('üïî Programando sincronizaci√≥n completa retrasada...');
    const syncTimeout = setTimeout(() => {
      console.log('üïí Ejecutando sincronizaci√≥n completa retrasada...');
      updateCurrentTrack();
    }, 3000);
    
    // Limpiar timeout al desmontar
    return () => clearTimeout(syncTimeout);
  }, [updateCurrentTrack]);

  const handlePlayPause = async () => {
    // Feedback visual inmediato
    setIsLoading(true);
    
    try {
      // Verificar el estado actual para saber si reproducir o pausar
      if (currentTrackInfo && currentTrackInfo.isPlaying) {
        // Si est√° reproduciendo, pausar
        console.log('‚è∏Ô∏è Pausando reproducci√≥n actual...');
        await spotifyService.pause();
        console.log('‚úÖ Reproducci√≥n pausada con √©xito');
        
        // Actualizar UI inmediatamente sin esperar polling
        setIsPlaying(false);
        setCurrentTrackInfo(prev => prev ? {...prev, isPlaying: false} : null);
      } else {
        // Si est√° pausado o no hay reproducci√≥n, intentar reproducir
        console.log('‚ñ∂Ô∏è Iniciando/reanudando reproducci√≥n...');
        
        // Intentar reproducir la √∫ltima track o reanudar
        await spotifyService.play();
        console.log('‚úÖ Reproducci√≥n iniciada con √©xito');
        
        // Actualizar UI inmediatamente sin esperar polling
        setIsPlaying(true);
        setCurrentTrackInfo(prev => prev ? {...prev, isPlaying: true} : null);
        
        // Sincronizar para asegurarnos de tener la informaci√≥n m√°s reciente
        console.log('üîÑ Sincronizando despu√©s de reproducir...');
        setTimeout(() => {
          updateCurrentTrack();
        }, 500);
      }
    } catch (error) {
      console.error('‚ùå Error al cambiar estado de reproducci√≥n:', error);
      
      // Mostrar notificaci√≥n de error
      toast.error('‚ùå Error al reproducir/pausar', {
        position: 'bottom-center'
      });
      
      // Forzar sincronizaci√≥n para recuperar estado real en caso de error
      console.log('üîÑ Resincronizando despu√©s de error...');
      setTimeout(() => {
        updateCurrentTrack();
      }, 1000);
    } finally {
      setIsLoading(false);
    }
  };

  const handleNext = async () => {
    setIsLoadingNext(true);
    console.log('‚è≠Ô∏è Next: Pasando a la siguiente canci√≥n...');
    
    try {
      const response = await spotifyService.next();
      console.log('‚úÖ Next: Comando enviado con √©xito');
      
      // Mostrar como reproduciendo inmediatamente para feedback al usuario
      setIsPlaying(true);
      
      // IMPORTANTE: Esperar un peque√±o delay para permitir que Spotify procese el cambio
      console.log('üïî Next: Esperando a que Spotify procese el cambio...');
      
      // Primer intento de sincronizaci√≥n despu√©s de un breve delay
      setTimeout(async () => {
        console.log('üîÑ Next: Forzando sincronizaci√≥n completa (primer intento)...');
        // Sincronizar tanto la canci√≥n actual como la cola
        await updateCurrentTrack(); // Esto ya llama a refreshQueue internamente
      }, 500);
      
      // Segundo intento para garantizar sincronizaci√≥n total
      setTimeout(async () => {
        console.log('üîÑ Next: Refrescando espec√≠ficamente la cola (segundo intento)...');
        await refreshQueue(); // Forzar actualizaci√≥n espec√≠fica de la cola
      }, 1500);
      
    } catch (error) {
      console.error('‚ùå Error pasando a siguiente canci√≥n:', error);
      
      // Mostrar notificaci√≥n de error
      toast.error('‚ùå Error al cambiar de canci√≥n', {
        position: 'bottom-center'
      });
      
      // Intentar recuperar en caso de error
      setTimeout(async () => {
        console.log('üì≤ Next: Intentando recuperar estado despu√©s de error...');
        await updateCurrentTrack();
      }, 800);
      
    } finally {
      setIsLoadingNext(false);
    }
  };

  const handlePrevious = async () => {
    setIsLoadingPrevious(true);
    console.log('‚èÆÔ∏è Previous: Volviendo a la canci√≥n anterior...');
    
    try {
      const response = await spotifyService.previous();
      console.log('‚úÖ Previous: Comando enviado con √©xito');
      
      // Mostrar como reproduciendo inmediatamente para feedback al usuario
      setIsPlaying(true);
      
      // IMPORTANTE: Esperar un peque√±o delay para permitir que Spotify procese el cambio
      console.log('üïî Previous: Esperando a que Spotify procese el cambio...');
      
      // Primer intento de sincronizaci√≥n despu√©s de un breve delay
      setTimeout(async () => {
        console.log('üîÑ Previous: Forzando sincronizaci√≥n completa (primer intento)...');
        // Sincronizar tanto la canci√≥n actual como la cola
        await updateCurrentTrack(); // Esto ya llama a refreshQueue internamente
      }, 500);
      
      // Segundo intento para garantizar sincronizaci√≥n total
      setTimeout(async () => {
        console.log('üîÑ Previous: Refrescando espec√≠ficamente la cola (segundo intento)...');
        await refreshQueue(); // Forzar actualizaci√≥n espec√≠fica de la cola
      }, 1500);
      
    } catch (error) {
      console.error('‚ùå Error pasando a canci√≥n anterior:', error);
      
      // Mostrar notificaci√≥n de error
      toast.error('‚ùå Error al cambiar de canci√≥n', {
        position: 'bottom-center'
      });
      
      // Intentar recuperar en caso de error
      setTimeout(async () => {
        console.log('üì≤ Previous: Intentando recuperar estado despu√©s de error...');
        await updateCurrentTrack();
      }, 800);
      
    } finally {
      setIsLoadingPrevious(false);
    }
  };

  // Usar el hook useLocation para determinar la ruta actual
  const location = useLocation();
  
  return (
    <AppContainer>
      <Header>
        <Logo>
          <FiMusic /> Asistente de Spotify
        </Logo>
        <Button onClick={logout}>
          <FiLogOut /> Cerrar sesi√≥n
        </Button>
      </Header>

      <Main>
        <PlayerSection>
          {currentTrack ? (
            <>
              <RefreshButton 
                onClick={updateCurrentTrack}
                className={isRefreshing ? 'loading' : ''}
                title="Actualizar estado de reproducci√≥n"
              >
                <FiRefreshCw size={16} />
              </RefreshButton>
              
              <QueueDisplay 
                currentTrack={currentTrackInfo || currentTrack} 
                queueItems={queueItems} 
              />
              <MusicPlayer
                currentTrack={currentTrackInfo || currentTrack}
                isPlaying={currentTrackInfo ? currentTrackInfo.isPlaying : isPlaying}
                onPlay={handlePlayPause}
                onPause={handlePlayPause}
                onNext={handleNext}
                onPrevious={handlePrevious}
                disabled={isLoading}
                isLoadingNext={isLoadingNext}
                isLoadingPrevious={isLoadingPrevious}
                onRefresh={updateCurrentTrack}
              />
            </>
          ) : null}
        </PlayerSection>
        
        {/* Navegaci√≥n entre secciones */}
        <Navigation>
          <NavList>
            <NavItem>
              <StyledNavLink to="/" end>
                <FiMessageSquare size={18} /> Asistente
              </StyledNavLink>
            </NavItem>
            <NavItem>
              <StyledNavLink to="/history">
                <FiBarChart2 size={18} /> Mi Historial
              </StyledNavLink>
            </NavItem>
          </NavList>
        </Navigation>

        <ContentSection>
          <AppRouter />
        </ContentSection>
      </Main>
    </AppContainer>
  );
};

export default AppLayout;
